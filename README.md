# recd2
============

32-64 канална записвачка върху UPD поток.

***

## Contributing

За да се започне работа по проекта, първо клонирай ранилището на кода локално.

    # Клонирай
    $ cd /path to my project/
    $ git clone ssh://git@git.balkantel.net/repo/git/recd2.git

Проекта е Qt5.8.0 базиран към момента, но няма тясна зависимост с новостите от
API 5.8.0, тестван и работещ с Qt5.6.0, Qt5.7.0, Qt5.8.0, разработен върху
qtcreator 4.2.1


### Development cycle

[PC]
Сървъра е UDP сокет базиран. Закача се на конфигурируем порт и започва да чака
входящ стрийм от сокета. Има пробна поддръжка на TCP сокет стрийм. Има помощен
инфо сървъ, чийто адрес и порт са конфигурират. UDP месидж сървър и демонизиращ
помощен инструмент, който може да се използва с опция `-d` или `--daemon` като
вариращ аргумент след името на програмата.

[HARDWARE]
Основния пордуцер на данни е 32 / 64 канална платка с АЦП, която хвърля фрейм на
определен клок интервал към PC сървъра. Текущия фрейм е не по-голям от от описаното:

```
   uint32_t counter
   uint8_t null[64]
   int16_t samples[512]
```

[PLUGIN]

Програмата поддържа гъвкаво плъгин апи, което не се интересува от броя на плъгини
заредени, засега се интересува от адекватен ред на подреждане на плъгините. Конвенцията
е, че първия плъгин е основен продусър като последния е основен консумър. Обикновенно
плъгините имат собствена нишка с цел да се избегне изчакването на обработката на данни.
Плъгините могат да правят копие на данните. Плъгините могат да модифицират данните също.
Плъгините могат да имат собствена конфигурация. Плъгините са класичекси `.so` обект,
който се зарежда на рънтайм.
Програмиста е отговорен за плъгина, който имплементира. Длъжен е да имплементира следния
интерфейс:
```
    #ifdef __cplusplus
    extern "C"{
    #endif
    struct interface_t
    {
        void    (*init)();                          // init the lib
        void    (*copy)(const void* src, void* dst, int len); // copy data
        int     (*put_ndata)(void* data, int len); // put N long data
        int     (*put_data)(void* data);           // put raw data
        void*   (*get_data)(void);                 // get worked data
        void    (*deinit)();                       // deinit lib
        int     (*main_proxy)(int, char**);        // pass caller args to lib
        void    (*setName)(const char*);           // sets the plugin name
        const char* (*getName)(void);              // gets the plugin name
        struct interface_t* getSelf();             // get this interface
        char name[256];                            // plugin name
        struct interface_t* nextPlugin;            // next loaded plugin
    };

    const struct interface_t* get_interface();
    #ifdef __cplusplus
    }
#endif
```

`init` - задължителна функция за всеки плъгин, викана от плъгин мениджъра. Сетъпва плъгина.
Вика се автоматично.

`deinit` - задължителна функция за всеки плъгин, викана от плъгин мениджъра. Почиства плъгина.
Вика се автоматично.

`copy_data` - неизползвана все още функция.

`put_data` - функция нужда от всеки продюсър плъгин, ненужа от финалния консюмър. Все пак
трябва да се знае, че последния плъгин е длъжен да прочисти датата ако няма да я праща на никого
след като свърши работа с нея. Обикновенно тази функция се вика от отделен тред, така, че повечето
плъгини имат междинни буфери за данните предадени през нея.

`put_ndata` - идентична на горната, но неизползвана, тъй като, примитива подаван обикновенно е
`QList<>` , чийто размер е известен чрез `count()` или `size()`. Може да се каже `unused`, но логиката
и е същата като на `put_data()`.

`get_data` - доскоро неизползвана, тази функция към момента връща инстанция на плъгина имплементирал
интерфейса, което може да се окаже ползено за външен конртол. Пример:
```
    Recorder* r = pmanager.getInterfaceByName("recorder").get_data();
    ...
    void* Recorder::get_data()
    {
        return &Instance();
    }
```

`main_proxy` - прокси функция към `main` на основния `app`. Ползва се да подаде аргументите
на отделните плъгини. Обикновенно ако плъгините зависят от конфиг файл или имат екстра опции.
Вика се автоматично.

`setName` - сетъпва името на плъгина. Не е задължителна но препоръчителна.

`getName` - взима името на плъгина. Не е задължитена но е препоръчителна.


[Utils]

`utils.pro` - статична библиотека, която се ползва от всички.


### Build

    `qmake-qt5`
    `make -j4`

### Deploy

Моля, реферирайте към: [Qt Deploy](http://doc.qt.io/qt-5/linux-deployment.html) за по-подробна информация
относно статичен линкинг.

### Usage

Употребата е следната:

`$ ./recd2 -d -c <path-to-conf-file>` - демонизирана и със заредена конфигурация

`$ ./recd2 -c <path-to-conf-file>`  - не демонизирана със заредена конфигурация

`$ ./recd2` - недемонизирана без заредена конфигурация, ще ползва хардкодната конфигурация,
строго непрепръчително, ползва се замо в девелопмънт.


### Config File

Минимална конфигурация за порграмата няма. Валиден конфиг файл е:
```
<Config />
```
Това е строго непрепоръчително. Все пак това ще извика фейлсейф конфиг.

Опционална конфигурация:

`<FrameData>` - таг описващ UDP пакета, който разменя HARDWARE и PC. Конфигуруруем. Ниво на
важност - Много важен! Има фейлсейф при липса.
Атрибутите му са следните:
`header` - 64 bytes. Месъдж хедър. Тук се очакват съобщения за обработка от желязото.

`channels` - брой канали за запис, обикновенно 32 или 64 но може и да са повече, както и
по-малко.

`samples` - семпли в канал. Колко 16 битови семпли има в канала. Максимума е 512 16 битови
числа (1024 байта). Конфигурацията се грижи за офсета и страйда кое от къде до къде е. Важно е
да се знае, че тотала `НЕ ТРЯБВА` да минава 1024 байта. Ще добавя превантивна логика.

Алгоритъма, който се ползва е следния: (променен)
```
    for i in CHANNELS:
        for j in SAMPLES_PER_CHAN:
            samples[j] = frame.data[j * CHANNELS + i];

```

`<HotSwap>` - таг описващ възможността да се спира записа след достигана не определен размер на файла
или след като е минало определено време. Важност - голяма. Основна логика. Има фейлсейф при липса.
`timeBased=enabled` - ако е определен като `enabled`, тага `maxSize` се омитва и се взима под внимание
тага `interval`. Описва след колко време да спре записа.

`timeBased=disabled` - определен като `disabled`, тага `maxSize` се взима под внимание и тага

`interval` става безсмилсен. Определя след какъв размер ще се извърши `hotSwap` на записите.

`maxSize` - виж по-горе. Приема аргумент в `MB` (case insensitive).

`interval` - виж по-горе. Приема времеви аргумент в `минути`.


`<Wave>` - таг описващ `wav` файла хедъра. Важност - голяма, без него записите са невъзможни.
Има фейлсейф конфиг при липсата му. `Знам какво правя` употреба, ако не знаете, по-добре не го
декларирайте а ползвайте фейлсейфа.
`samplesPerFrame` - известен като `SPF` - честота на семплирте `8Khz - 44khz`.

`bitsPerSec` - битове в секунда.

`fmtLenght` - дължина на формата, обикновенно `16`.

`audioFormat` - аудио формат. `1` е стандарт. Класически `wav`.

`channels` - канали за файл. В текущия случай са един. Но може и да са повече. Отново помислете
върху `Знам какво правя`.

`endiness` - байтово нареждане. Голям или малък байтов ред. Дали има нужда да сменим реда на байтовете
или не. Не го ползвам засега.


`<Paths>` - пътища и директории. Малка значимост за порграмата. Описва кое къде отива, ако нямаме таг,
ще се ползва основната директория за всичко, което не е добра идея.
`records="name"` - добава в основната директория `name` поддиректория в която ще се записват аудио
записите.

`logs="name"` - добаяв в основната директория `name` поддиректория за лог системата.


`<Network>` - Вид комункиация между истройствата. Много голяма важност. Има файлсейф режим.

`transport` - вид транспорт, `udp` или `tcp`. Онсовната ни поддръжка е `udp` протоколизиране, но
като експериментална опция добавих и `tcp`.

`port` - порт на който слушаме за входящи стриимове.


`<Log>` - Лог файла на основната програма. Важна конфигурация. Има фейлсейф режим.

`name` - име на лог файла.

`timestamp` - да добави таймстамп към името на лога.

`speed` - колко често да се вика нишката на писането в лога, тъй-като не целя 100% риъл тайм,
логгинг мога да си позволя да го забавя, за де се обработват други неща. Ако не е достатъчно, може
да се сложи `speed=0` което ще го пусне в риъл тайм. От програмно ниво, това е времето в милисекунди,
в което спи логер нишката.


`<LogServer>` - Месъдж сървъра, интерпроцесната комункиация и сървър към който всеки логва съобщенията
си. Не голяма важност, но поддържа фейлсефт.

`port` - на кой порт е сървъра.


`<HeartBeat>` - Периодична сигнализация на живота. Не важен и неизползван към момента.

`timepout` - интервал на изшращане на `hearbeat`.

`port` - на кой порт да пращаме `heartbeat`.

`host` - на кой хост да пращаме `heartbeat`. Примерен е `localdomain`.

`enabled` - включен или изключен. Може хоста да поиска динамично включване. По дефолт - спрян.


`<Plugin>` - Плъгин концепция. Незадължителна. Неизвестен брой. `Знам какво правя` е задължителна
концепция при нареждане на плъгините. `WebConfig` ще е отговорен да проведе потребителя към конфигурация,
писане на ръка е `СТРОГО НЕЖЕЛАТЕЛНО`, освен ако `Знам какво правя` е на лице. Може програмиста, да добави
дебъг плъгин например за да засече евентуална грешка, но краен потребител трябва да има фиксиран избор
от плъгини през `WebConfig` -a.

`name` - име на плъгина. Нека имената бъдат уникални за плъгин. Може да са еднакви но ефектите ще са
странични.

`oreder` - ред на зареждане. Неизползван засега.

`enabled` - неизползван засега. Идеята е да се каже дали менидъжра да извика `init` при стартиране или
може би след това.

`path` - локация на плъгина (`.so`). Пълен път.

`conf` - път към специфичние конфиг файл на плъгина. Може да се види примера в проекта. `DFT`.

Боря на заредени плъгини не е важен, но последователността е важна. От програмистка гледа точка,
плъгина е длъжен да работи с локални данни за по-добър перформънс и сигурност. Прост пример:

Примерна употреба:
Плъгин рънър на нишка - основен продюсър:
```
    while(1) {
        // do something with local data
        put_data(local_data); // pass to other.
    }
```

Плъгин `put_frame` - типичен плъгин:

```
    put_data(void* data) {
        LOCK();
        // copy to local_data - копирай локална дата в собствен буфер.
        UNLOCK();
        if (m_iface.next != nullptr) {
            m_iface.next->put_data(data); // виж има ли селдващ и подай нататък
        } else { // ако сме последни - почисти или финализирал.
            // clean data
            QList<int>* ls = (QList<int>*) data;
            ls->clear();
        }
   }
```


## BUGS
(fill in later)


## Builtin PLUGINS:

### TESTING

Тестови плъгини за експерименти.
1. Ползвай `test-prducer` да генерираш тестова дата.
2. Ползвай `test-consumer` да цонсумираш и рабтиш върху дата.
3. `udp-client` - рефкексна външна пограма на `HARDWARE DEV`, която може да генерира
`udp` пакети, чете от файл и го стриимва.
4. `NULL` - нулев плъгин, той не прави нищо, просто доказа концепцията за подаване на
данните.


### DTMF DETECTOR
Dtmf плъгин. Засича DTMF сигнали. Автор: `Plyashkevich Viatcheslav <plyashkevich@yandex.ru>`.
Разширена функционалост и конфигуруруеми опции от мен. Също така и собствен конфиг файл.
Може да се види теста на автора в `DFT/main.cpp`

### MD5 CHECKSUM (Pending)
[Pending]


## TOOLS
`topme` - мой питон скрипт, който вика `top -H -p <proc name>`, за да следя порграмата си.
Ex.: `topme recd2`



<ilian.zapryanov@balkantel.net>

И.Z.
